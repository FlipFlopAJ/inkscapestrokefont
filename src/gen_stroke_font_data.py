#!/usr/bin/env python
# -*- coding: utf-8 -*-

'''
Inkscape extension to generate the data for the stroke font glyphs 
designed in the current SVG. The current SVG must be generated with the
'Create Font Design Template' extension

The data generated by this effect is used by the 'Render Text' extension, 
to render text with the selected stroke font.

Copyright (C) 2019  Shrinivas Kulkarni

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License along
with this program; if not, write to the Free Software Foundation, Inc.,
51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
'''

import inkex, sys, os, re, math
from cubicsuperpath import CubicSuperPath, formatPath
import simplepath
from bezmisc import bezierlengthSimpson
from simpletransform import refinedBBox, applyTransformToPath, \
    applyTransformToPoint, parseTransform

sys.path.append(os.path.dirname(os.path.abspath(__file__))) 
from stroke_font_common import *

def getNearestGuide(guides, minVal, coIdx, hSeq = None):
    if(guides == None or len(guides) == 0):
        return None, None
        
    if(hSeq != None):
        guides = [g for g in guides if g[0].get(hSeqAName) == hSeq]

    if(len(guides) == 1):
        return guides[0]
        
    for i, guide in enumerate(guides):
        pp = guide[1]
        #pp format [['M',[x1,y1]],['L',[x2,y2]]]
        diff = abs(pp[0][1][coIdx] - minVal)
        
        if(i > 0 and diff > minDiff):
            return guides[i-1]
            
        minDiff = diff
        
    return guides[-1]
    
def getFontSizeFromGuide(pp, vgScaleFact):    
    #pp format [['M',[x1,y1]],['L',[x2,y2]]]
    lHeight = abs(float(pp[1][1][1]) - pp[0][1][1])
    return round(lHeight / vgScaleFact, 2)
    
#Apply transform attribute (only straight lines, no arcs etc.)
def transformedParsedPath(elem):
    pp = simplepath.parsePath(elem.get('d'))
    
    try:
        transf = elem.get('transform')
        mat = parseTransform(transf)
        
        #pp format [['M',[x1,y1]],['L',[x2,y2]]]
        for dElem in pp:
            for i in range(1, len(dElem)):
                param = dElem[i]
                t1 = [[param[x], param[x+1]] for x in range(0, len(param), 2)]
                for t1Elem in t1:
                    simpletransform.applyTransformToPoint(mat, t1Elem)
                dElem[i] = [x for l in t1 for x in l]
        elem.set('d', simplepath.formatPath(pp))        
    except:
        #Don't break
        pass
    
    return pp

def updateData(strokeFontData, glyphPathElems, hGuides, lvGuides, rvGuides, rightOffsetType):    
    for elem in glyphPathElems:
        char = elem.get('id')
        path = CubicSuperPath(simplepath.parsePath(elem.get('d')))
        
        #Just in case...
        transf = elem.get('transform')
        mat = parseTransform(transf)
        applyTransformToPath(mat, path)

        xmin, xmax, ymin, ymax = refinedBBox(path)
        
        #Nearest to the bottom (ymax)
        hg = getNearestGuide(hGuides, ymax, 1)
        hseq = hg[0].get('seq')
        hgp = hg[1]
        #hgp format: [['M',[x1,y1]],['H',[x2,y2]]]
        hgY = hgp[0][1][1]
        
        #Nearest to the left edge (xmin)
        lvg = getNearestGuide(lvGuides, xmin, 0, hseq)            
        lvgp = lvg[1]
        #lvgp format: [['M',[x1,y1]],['V',[x2,y2]]]
        lvgX = lvgp[0][1][0]
        
        rvgX = None
        if(rvGuides != None and len(rvGuides) > 0):
            #Nearest to the right edge (xmax)
            rvg = getNearestGuide(rvGuides, xmax, 0, hseq)
            rvgp = rvg[1]
            #rvgp format: [['M',[x1,y1]],['V',[x2,y2]]]
            rvgX = rvgp[0][1][0]
        
        npath = []
        
        maxLenSp = None
        maxSpLen = 0
        
        for subpath in path:
            nsub = []
            spLen = 0
            prevSeg = None
            for seg in subpath:
                nseg = []
                for pt in seg:
                    x = round(pt[0] - lvgX, 2)
                    y = round(pt[1] - hgY, 2)
                    nseg.append([x, y])
                nsub.append(nseg)
                
                #Calculate only if needed
                if(rightOffsetType == 'lastNode' and prevSeg != None):
                    spLen += bezierlengthSimpson((prevSeg[1], prevSeg[2], seg[0], seg[1]), 
                        tolerance = 0.01)
                prevSeg = seg
                        
            npath.append(nsub)
            if(rightOffsetType == 'lastNode' and spLen > maxSpLen):
                maxSpLen = spLen
                maxLenSp = subpath
        
        if(rightOffsetType == 'lastNode'):
            lastNode = maxLenSp[-1][-1]
            rOffset = lastNode[0] - lvgX
        elif(rvgX != None):
            rOffset = rvgX - lvgX
        else:
            rOffset = xmax - lvgX

        rOffset = round(rOffset, 2)

        pathStr = formatPath(npath)
        bbox = [round(xmin - lvgX, 2), round(xmax - lvgX, 2), 
            round(ymin - hgY, 2), round(ymax - hgY, 2)]
            
        strokeFontData.updateGlyph(char, bbox, rOffset, pathStr)
            
class GenStrokeFontData(inkex.Effect):

    def __init__(self):
        inkex.Effect.__init__(self)
        
        self.OptionParser.add_option('--fontName', action = 'store',
          type = 'string', dest = 'fontName', help = 'Name of the font to be created')

        self.OptionParser.add_option('--rightOffsetType', action = 'store',
          type = 'string', dest = 'rightOffsetType', 
          help = 'Calculation of the right offset of the glyph')

        self.OptionParser.add_option('--crInfo', action = 'store',
          type = 'string', dest = 'crInfo', help = 'Copyright and license details')

        self.OptionParser.add_option("--tab", action="store", 
          type="string", dest="tab", default="sampling", help="Tab") 
          
    def getGuides(self, idName, idVal):        
        return [(pn, transformedParsedPath(pn)) for pn in self.document.xpath('//svg:path', \
            namespaces = inkex.NSS) if pn.get(idName) == idVal]
            
    def effect(self):
        fontName = self.options.fontName
        rightOffsetType = self.options.rightOffsetType        
        crInfo = self.options.crInfo
        
        gaName = CommonDefs.guideAttribName        
        hSeqAName = CommonDefs.hSeqAttribName
        vSeqAName = CommonDefs.vSeqAttribName

        #Guide is a tuple of xml elem and parsed path
        hGuides = self.getGuides(gaName, CommonDefs.hGuideAttrib)
        
        #A quick check to see if there are duplicates
        uniqueSeqNoCnt = len(set([g[0].get(hSeqAName) for g in hGuides]))
        if(len(hGuides) != uniqueSeqNoCnt):
            inkex.errormsg("Multiple guides with the same sequence number, \
please create the template only once.")
            return 
            
        hGuides = sorted(hGuides, key = lambda p: int(p[0].get(hSeqAName)))
        
        lvGuides = self.getGuides(gaName, CommonDefs.lvGuideAttrib)
        lvGuides = sorted(lvGuides, \
            key = lambda p: (int(p[0].get(hSeqAName)), int(p[0].get(vSeqAName))))
                
        rvGuides = self.getGuides(gaName, CommonDefs.rvGuideAttrib)
        rvGuides = sorted(rvGuides, \
            key = lambda p: (int(p[0].get(hSeqAName)),int(p[0].get(vSeqAName))))
                
        
                        
        if(len(lvGuides) == 0  or len(hGuides) == 0):
            inkex.errormsg("Missing guides. Please use the Create Font Design \
Template extension to design the font.")
            return 

        fontSize = getFontSizeFromGuide(lvGuides[0][1], CommonDefs.vgScaleFact)

        dataFilePath = os.path.dirname(os.path.abspath(__file__)) + "/" + CommonDefs.dataFileName    
        doc = getDataFileDoc(dataFilePath)
        strokeFontData = FontData(doc, fontName)
        strokeFontData.scaleFont(fontSize)
        
        if(crInfo != None and crInfo.strip() != ""):
            strokeFontData.setCRInfo(crInfo)

        glyphPaths = [p for p in self.document.xpath('//svg:path',namespaces=inkex.NSS) \
                if (len(p.get('id'))==1)]
            
        updateData(strokeFontData, glyphPaths, hGuides, lvGuides, rvGuides, rightOffsetType)
        strokeFontData.updateFontElemInDoc(doc)
        updateDataFile(doc, dataFilePath)
        
        syncFontList(doc)

try:
    effect = GenStrokeFontData()
    effect.affect()
except:    
    inkex.errormsg("The data was not generated due to an error. \
If you are creating non-english glyphs then save the document, re-open and \
try generating the font data once again.")
